<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>异步遍历器 | oliveying</title>
    <meta name="description" content="前端知识，对前端遇到的问题进行总结">
    <link rel="icon" href="/knowledge/img/favicon.ico">
    
    <link rel="preload" href="/knowledge/assets/css/0.styles.ace1f307.css" as="style"><link rel="preload" href="/knowledge/assets/js/app.0598c8f5.js" as="script"><link rel="preload" href="/knowledge/assets/js/79.74931317.js" as="script"><link rel="prefetch" href="/knowledge/assets/js/10.90293d7f.js"><link rel="prefetch" href="/knowledge/assets/js/100.54b65d7d.js"><link rel="prefetch" href="/knowledge/assets/js/101.df59ff78.js"><link rel="prefetch" href="/knowledge/assets/js/102.b459cf77.js"><link rel="prefetch" href="/knowledge/assets/js/103.801a0803.js"><link rel="prefetch" href="/knowledge/assets/js/104.35634380.js"><link rel="prefetch" href="/knowledge/assets/js/105.1340a87f.js"><link rel="prefetch" href="/knowledge/assets/js/106.a0fdd781.js"><link rel="prefetch" href="/knowledge/assets/js/107.8ae9e909.js"><link rel="prefetch" href="/knowledge/assets/js/108.3a388378.js"><link rel="prefetch" href="/knowledge/assets/js/109.dabe24b4.js"><link rel="prefetch" href="/knowledge/assets/js/11.bef852fa.js"><link rel="prefetch" href="/knowledge/assets/js/110.07b4d5f0.js"><link rel="prefetch" href="/knowledge/assets/js/111.5cef168d.js"><link rel="prefetch" href="/knowledge/assets/js/112.a0012529.js"><link rel="prefetch" href="/knowledge/assets/js/113.b6d3edab.js"><link rel="prefetch" href="/knowledge/assets/js/114.f8934554.js"><link rel="prefetch" href="/knowledge/assets/js/115.95b7a85d.js"><link rel="prefetch" href="/knowledge/assets/js/116.6d6f7cf8.js"><link rel="prefetch" href="/knowledge/assets/js/117.18954faf.js"><link rel="prefetch" href="/knowledge/assets/js/118.5b67121f.js"><link rel="prefetch" href="/knowledge/assets/js/119.a6c7a42d.js"><link rel="prefetch" href="/knowledge/assets/js/12.9cccb9fc.js"><link rel="prefetch" href="/knowledge/assets/js/120.512d2791.js"><link rel="prefetch" href="/knowledge/assets/js/121.e1effb4c.js"><link rel="prefetch" href="/knowledge/assets/js/122.ae9f59f3.js"><link rel="prefetch" href="/knowledge/assets/js/123.a6bd35c6.js"><link rel="prefetch" href="/knowledge/assets/js/124.6db13bb2.js"><link rel="prefetch" href="/knowledge/assets/js/125.e86a5e41.js"><link rel="prefetch" href="/knowledge/assets/js/126.0c7935b6.js"><link rel="prefetch" href="/knowledge/assets/js/127.515a6c02.js"><link rel="prefetch" href="/knowledge/assets/js/128.19f4d028.js"><link rel="prefetch" href="/knowledge/assets/js/129.7f4b6536.js"><link rel="prefetch" href="/knowledge/assets/js/13.4be5d483.js"><link rel="prefetch" href="/knowledge/assets/js/130.6076ef5c.js"><link rel="prefetch" href="/knowledge/assets/js/131.a2ffec16.js"><link rel="prefetch" href="/knowledge/assets/js/132.631a0595.js"><link rel="prefetch" href="/knowledge/assets/js/133.6b55e3e8.js"><link rel="prefetch" href="/knowledge/assets/js/134.87933f62.js"><link rel="prefetch" href="/knowledge/assets/js/135.af22a8bb.js"><link rel="prefetch" href="/knowledge/assets/js/136.3bc00667.js"><link rel="prefetch" href="/knowledge/assets/js/137.884c009b.js"><link rel="prefetch" href="/knowledge/assets/js/138.39bf5afd.js"><link rel="prefetch" href="/knowledge/assets/js/139.01726c36.js"><link rel="prefetch" href="/knowledge/assets/js/14.e5df052b.js"><link rel="prefetch" href="/knowledge/assets/js/140.2aaefea5.js"><link rel="prefetch" href="/knowledge/assets/js/141.6de7c496.js"><link rel="prefetch" href="/knowledge/assets/js/142.f38e592f.js"><link rel="prefetch" href="/knowledge/assets/js/143.55155cdd.js"><link rel="prefetch" href="/knowledge/assets/js/144.b93b95ca.js"><link rel="prefetch" href="/knowledge/assets/js/145.c1305cca.js"><link rel="prefetch" href="/knowledge/assets/js/146.2f0e65ab.js"><link rel="prefetch" href="/knowledge/assets/js/147.adf879b8.js"><link rel="prefetch" href="/knowledge/assets/js/148.4c0b9ca9.js"><link rel="prefetch" href="/knowledge/assets/js/149.556ecf2d.js"><link rel="prefetch" href="/knowledge/assets/js/15.cd91cd34.js"><link rel="prefetch" href="/knowledge/assets/js/150.10f0eb80.js"><link rel="prefetch" href="/knowledge/assets/js/151.e15feac0.js"><link rel="prefetch" href="/knowledge/assets/js/152.204b9221.js"><link rel="prefetch" href="/knowledge/assets/js/153.f93a89f0.js"><link rel="prefetch" href="/knowledge/assets/js/154.6804d0a6.js"><link rel="prefetch" href="/knowledge/assets/js/155.bbbd5504.js"><link rel="prefetch" href="/knowledge/assets/js/156.9ab5f4a5.js"><link rel="prefetch" href="/knowledge/assets/js/157.fe241494.js"><link rel="prefetch" href="/knowledge/assets/js/158.f86e4b53.js"><link rel="prefetch" href="/knowledge/assets/js/159.e19c17d1.js"><link rel="prefetch" href="/knowledge/assets/js/16.e060ba55.js"><link rel="prefetch" href="/knowledge/assets/js/160.5be567d6.js"><link rel="prefetch" href="/knowledge/assets/js/161.2f1f189d.js"><link rel="prefetch" href="/knowledge/assets/js/162.ad66431a.js"><link rel="prefetch" href="/knowledge/assets/js/163.e39c161f.js"><link rel="prefetch" href="/knowledge/assets/js/164.2e629996.js"><link rel="prefetch" href="/knowledge/assets/js/165.e0b4d29a.js"><link rel="prefetch" href="/knowledge/assets/js/166.8957011a.js"><link rel="prefetch" href="/knowledge/assets/js/167.af6e30b5.js"><link rel="prefetch" href="/knowledge/assets/js/168.0d5a3a46.js"><link rel="prefetch" href="/knowledge/assets/js/169.dcd80ee1.js"><link rel="prefetch" href="/knowledge/assets/js/17.cbedd678.js"><link rel="prefetch" href="/knowledge/assets/js/170.88420fa6.js"><link rel="prefetch" href="/knowledge/assets/js/171.c3e44e8b.js"><link rel="prefetch" href="/knowledge/assets/js/172.c706254a.js"><link rel="prefetch" href="/knowledge/assets/js/173.1b1ca418.js"><link rel="prefetch" href="/knowledge/assets/js/174.460ef2a7.js"><link rel="prefetch" href="/knowledge/assets/js/175.8807c965.js"><link rel="prefetch" href="/knowledge/assets/js/176.1dc1aa1e.js"><link rel="prefetch" href="/knowledge/assets/js/177.1e998b52.js"><link rel="prefetch" href="/knowledge/assets/js/178.280f116e.js"><link rel="prefetch" href="/knowledge/assets/js/179.f40358e9.js"><link rel="prefetch" href="/knowledge/assets/js/18.65be3687.js"><link rel="prefetch" href="/knowledge/assets/js/180.9fb0036d.js"><link rel="prefetch" href="/knowledge/assets/js/181.ef8f73dd.js"><link rel="prefetch" href="/knowledge/assets/js/182.e1a9b2a1.js"><link rel="prefetch" href="/knowledge/assets/js/183.6189e9c5.js"><link rel="prefetch" href="/knowledge/assets/js/184.5e6b6e10.js"><link rel="prefetch" href="/knowledge/assets/js/19.48e761c3.js"><link rel="prefetch" href="/knowledge/assets/js/2.89893ef2.js"><link rel="prefetch" href="/knowledge/assets/js/20.8fa2b2b5.js"><link rel="prefetch" href="/knowledge/assets/js/21.9f331d26.js"><link rel="prefetch" href="/knowledge/assets/js/22.b0bfdc37.js"><link rel="prefetch" href="/knowledge/assets/js/23.6b3d144f.js"><link rel="prefetch" href="/knowledge/assets/js/24.775a4a2f.js"><link rel="prefetch" href="/knowledge/assets/js/25.a98881a8.js"><link rel="prefetch" href="/knowledge/assets/js/26.30d4fc27.js"><link rel="prefetch" href="/knowledge/assets/js/27.adb1c85b.js"><link rel="prefetch" href="/knowledge/assets/js/28.cd7e5a5a.js"><link rel="prefetch" href="/knowledge/assets/js/29.a8ee4c1c.js"><link rel="prefetch" href="/knowledge/assets/js/3.3d73560c.js"><link rel="prefetch" href="/knowledge/assets/js/30.72b61c10.js"><link rel="prefetch" href="/knowledge/assets/js/31.d91e0a0a.js"><link rel="prefetch" href="/knowledge/assets/js/32.0973ffc0.js"><link rel="prefetch" href="/knowledge/assets/js/33.33b48d6f.js"><link rel="prefetch" href="/knowledge/assets/js/34.8c5155cd.js"><link rel="prefetch" href="/knowledge/assets/js/35.0f3a589e.js"><link rel="prefetch" href="/knowledge/assets/js/36.36518d26.js"><link rel="prefetch" href="/knowledge/assets/js/37.71d76436.js"><link rel="prefetch" href="/knowledge/assets/js/38.acf72ddf.js"><link rel="prefetch" href="/knowledge/assets/js/39.64cecb9e.js"><link rel="prefetch" href="/knowledge/assets/js/4.54e0cd6b.js"><link rel="prefetch" href="/knowledge/assets/js/40.e6688e63.js"><link rel="prefetch" href="/knowledge/assets/js/41.9ef490b9.js"><link rel="prefetch" href="/knowledge/assets/js/42.0596e224.js"><link rel="prefetch" href="/knowledge/assets/js/43.d29bdb86.js"><link rel="prefetch" href="/knowledge/assets/js/44.5646fdef.js"><link rel="prefetch" href="/knowledge/assets/js/45.02bc0141.js"><link rel="prefetch" href="/knowledge/assets/js/46.ccc5a57c.js"><link rel="prefetch" href="/knowledge/assets/js/47.90d8f911.js"><link rel="prefetch" href="/knowledge/assets/js/48.60ceb17f.js"><link rel="prefetch" href="/knowledge/assets/js/49.614ffa70.js"><link rel="prefetch" href="/knowledge/assets/js/5.b3e5f51b.js"><link rel="prefetch" href="/knowledge/assets/js/50.cc548896.js"><link rel="prefetch" href="/knowledge/assets/js/51.2ed7e24a.js"><link rel="prefetch" href="/knowledge/assets/js/52.e6a09b37.js"><link rel="prefetch" href="/knowledge/assets/js/53.5ba1b311.js"><link rel="prefetch" href="/knowledge/assets/js/54.065067d9.js"><link rel="prefetch" href="/knowledge/assets/js/55.e31ee302.js"><link rel="prefetch" href="/knowledge/assets/js/56.334ac36a.js"><link rel="prefetch" href="/knowledge/assets/js/57.75a2eb60.js"><link rel="prefetch" href="/knowledge/assets/js/58.8a63cf7e.js"><link rel="prefetch" href="/knowledge/assets/js/59.0867127e.js"><link rel="prefetch" href="/knowledge/assets/js/6.822f4588.js"><link rel="prefetch" href="/knowledge/assets/js/60.65bd9a6b.js"><link rel="prefetch" href="/knowledge/assets/js/61.4c2c8030.js"><link rel="prefetch" href="/knowledge/assets/js/62.34a8f75c.js"><link rel="prefetch" href="/knowledge/assets/js/63.f675f96b.js"><link rel="prefetch" href="/knowledge/assets/js/64.b04cc679.js"><link rel="prefetch" href="/knowledge/assets/js/65.550c226c.js"><link rel="prefetch" href="/knowledge/assets/js/66.2044045f.js"><link rel="prefetch" href="/knowledge/assets/js/67.29374520.js"><link rel="prefetch" href="/knowledge/assets/js/68.0cef07a7.js"><link rel="prefetch" href="/knowledge/assets/js/69.38bab0b1.js"><link rel="prefetch" href="/knowledge/assets/js/7.710425be.js"><link rel="prefetch" href="/knowledge/assets/js/70.89117fb4.js"><link rel="prefetch" href="/knowledge/assets/js/71.1c0371ec.js"><link rel="prefetch" href="/knowledge/assets/js/72.7f6197f2.js"><link rel="prefetch" href="/knowledge/assets/js/73.320d8514.js"><link rel="prefetch" href="/knowledge/assets/js/74.9700feb7.js"><link rel="prefetch" href="/knowledge/assets/js/75.e2b75082.js"><link rel="prefetch" href="/knowledge/assets/js/76.d3102da4.js"><link rel="prefetch" href="/knowledge/assets/js/77.8753179d.js"><link rel="prefetch" href="/knowledge/assets/js/78.bab2e95d.js"><link rel="prefetch" href="/knowledge/assets/js/8.266590d3.js"><link rel="prefetch" href="/knowledge/assets/js/80.218fab37.js"><link rel="prefetch" href="/knowledge/assets/js/81.8fba1997.js"><link rel="prefetch" href="/knowledge/assets/js/82.7c32c926.js"><link rel="prefetch" href="/knowledge/assets/js/83.0a90928d.js"><link rel="prefetch" href="/knowledge/assets/js/84.2cdb8d68.js"><link rel="prefetch" href="/knowledge/assets/js/85.1db0afa8.js"><link rel="prefetch" href="/knowledge/assets/js/86.92ec1746.js"><link rel="prefetch" href="/knowledge/assets/js/87.2f716bc1.js"><link rel="prefetch" href="/knowledge/assets/js/88.16d5626c.js"><link rel="prefetch" href="/knowledge/assets/js/89.dfc7cce9.js"><link rel="prefetch" href="/knowledge/assets/js/9.6ac483ba.js"><link rel="prefetch" href="/knowledge/assets/js/90.b4f752f0.js"><link rel="prefetch" href="/knowledge/assets/js/91.21a4838e.js"><link rel="prefetch" href="/knowledge/assets/js/92.919a90b6.js"><link rel="prefetch" href="/knowledge/assets/js/93.1e38886a.js"><link rel="prefetch" href="/knowledge/assets/js/94.0496394f.js"><link rel="prefetch" href="/knowledge/assets/js/95.499c2e4e.js"><link rel="prefetch" href="/knowledge/assets/js/96.7b6f1886.js"><link rel="prefetch" href="/knowledge/assets/js/97.d639e146.js"><link rel="prefetch" href="/knowledge/assets/js/98.96f0eb9b.js"><link rel="prefetch" href="/knowledge/assets/js/99.3840d24e.js">
    <link rel="stylesheet" href="/knowledge/assets/css/0.styles.ace1f307.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/knowledge/" class="home-link router-link-active"><!----> <span class="site-name">oliveying</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/knowledge/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">book</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/bgoodparts/" class="nav-link">语言精粹</a></li><li class="dropdown-item"><!----> <a href="/knowledge/http/" class="nav-link">图解http</a></li><li class="dropdown-item"><!----> <a href="/knowledge/es6/" class="nav-link router-link-active">es6</a></li><li class="dropdown-item"><!----> <a href="/knowledge/javascript/" class="nav-link">javascript教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/html/" class="nav-link">html</a></li><li class="dropdown-item"><!----> <a href="/knowledge/css/" class="nav-link">css</a></li><li class="dropdown-item"><!----> <a href="/knowledge/js/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/knowledge/jsHigh/" class="nav-link">javascriptHigh</a></li><li class="dropdown-item"><!----> <a href="/knowledge/h5/" class="nav-link">h5最新用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/knowledge/brower/" class="nav-link">浏览器特性</a></li><li class="dropdown-item"><!----> <a href="/knowledge/d3/" class="nav-link">d3</a></li><li class="dropdown-item"><!----> <a href="/knowledge/typescript/" class="nav-link">typescript</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">总结</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/summary/" class="nav-link">总结</a></li><li class="dropdown-item"><!----> <a href="/knowledge/interview/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/knowledge/problem/" class="nav-link">problem</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">扩展</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/start/" class="nav-link">启动</a></li><li class="dropdown-item"><!----> <a href="/knowledge/tool/" class="nav-link">工具用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/markdown/" class="nav-link">markDown</a></li><li class="dropdown-item"><!----> <a href="/knowledge/linux/" class="nav-link">linux</a></li><li class="dropdown-item"><!----> <a href="/knowledge/mac/" class="nav-link">mac</a></li><li class="dropdown-item"><!----> <a href="/knowledge/develop/" class="nav-link">提升</a></li><li class="dropdown-item"><!----> <a href="/knowledge/redis/" class="nav-link">redis</a></li></ul></div></div> <a href="https://github.com/oliveying/knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/knowledge/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">book</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/bgoodparts/" class="nav-link">语言精粹</a></li><li class="dropdown-item"><!----> <a href="/knowledge/http/" class="nav-link">图解http</a></li><li class="dropdown-item"><!----> <a href="/knowledge/es6/" class="nav-link router-link-active">es6</a></li><li class="dropdown-item"><!----> <a href="/knowledge/javascript/" class="nav-link">javascript教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/html/" class="nav-link">html</a></li><li class="dropdown-item"><!----> <a href="/knowledge/css/" class="nav-link">css</a></li><li class="dropdown-item"><!----> <a href="/knowledge/js/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/knowledge/jsHigh/" class="nav-link">javascriptHigh</a></li><li class="dropdown-item"><!----> <a href="/knowledge/h5/" class="nav-link">h5最新用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/knowledge/brower/" class="nav-link">浏览器特性</a></li><li class="dropdown-item"><!----> <a href="/knowledge/d3/" class="nav-link">d3</a></li><li class="dropdown-item"><!----> <a href="/knowledge/typescript/" class="nav-link">typescript</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">总结</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/summary/" class="nav-link">总结</a></li><li class="dropdown-item"><!----> <a href="/knowledge/interview/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/knowledge/problem/" class="nav-link">problem</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">扩展</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/start/" class="nav-link">启动</a></li><li class="dropdown-item"><!----> <a href="/knowledge/tool/" class="nav-link">工具用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/markdown/" class="nav-link">markDown</a></li><li class="dropdown-item"><!----> <a href="/knowledge/linux/" class="nav-link">linux</a></li><li class="dropdown-item"><!----> <a href="/knowledge/mac/" class="nav-link">mac</a></li><li class="dropdown-item"><!----> <a href="/knowledge/develop/" class="nav-link">提升</a></li><li class="dropdown-item"><!----> <a href="/knowledge/redis/" class="nav-link">redis</a></li></ul></div></div> <a href="https://github.com/oliveying/knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/knowledge/es6/let和const.html" class="sidebar-link">es6 let const</a></li><li><a href="/knowledge/es6/变量的解构赋值.html" class="sidebar-link">变量的解构赋值</a></li><li><a href="/knowledge/es6/字符串的扩展.html" class="sidebar-link">字符串的扩展</a></li><li><a href="/knowledge/es6/字符串的新增方法.html" class="sidebar-link">String.fromCodePoint()</a></li><li><a href="/knowledge/es6/正则的扩展.html" class="sidebar-link">正则的扩展</a></li><li><a href="/knowledge/es6/数值的扩展.html" class="sidebar-link">数值的扩展</a></li><li><a href="/knowledge/es6/函数的扩展.html" class="sidebar-link">函数的扩展</a></li><li><a href="/knowledge/es6/对象的扩展.html" class="sidebar-link">对象的扩展</a></li><li><a href="/knowledge/es6/对象的新增方法.html" class="sidebar-link">对象的新增方法</a></li><li><a href="/knowledge/es6/symbol.html" class="sidebar-link">Symbol</a></li><li><a href="/knowledge/es6/set和map数据结构.html" class="sidebar-link">set 和 map 数据结构</a></li><li><a href="/knowledge/es6/proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/knowledge/es6/reflect.html" class="sidebar-link">reflect</a></li><li><a href="/knowledge/es6/Promise对象.html" class="sidebar-link">Promise</a></li><li><a href="/knowledge/es6/Iterator和for...of循环.html" class="sidebar-link">Iterator和for...of循环</a></li><li><a href="/knowledge/es6/Generator函数的语法.html" class="sidebar-link">Generator函数的语法</a></li><li><a href="/knowledge/es6/Generator函数的异步应用.html" class="sidebar-link">Generator函数的异步应用</a></li><li><a href="/knowledge/es6/Async.html" class="sidebar-link">Async</a></li><li><a href="/knowledge/es6/Class的基本语法.html" class="sidebar-link">Class的基本语法</a></li><li><a href="/knowledge/es6/Class的继承.html" class="sidebar-link">Class的继承</a></li><li><a href="/knowledge/es6/Module的语法.html" class="sidebar-link">Module的语法</a></li><li><a href="/knowledge/es6/Module 的加载实现.html" class="sidebar-link">Module 的加载实现</a></li><li><a href="/knowledge/es6/编程风格.html" class="sidebar-link">编程风格</a></li><li><a href="/knowledge/es6/读懂ECMAScript规格.html" class="sidebar-link">读懂ECMAScript规格</a></li><li><a href="/knowledge/es6/异步遍历器.html" class="active sidebar-link">异步遍历器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/knowledge/es6/异步遍历器.html#同步遍历器的问题" class="sidebar-link">同步遍历器的问题</a></li></ul></li></ul> </div> <div class="page"> <div class="content"><h1 id="异步遍历器"><a href="#异步遍历器" aria-hidden="true" class="header-anchor">#</a> 异步遍历器</h1> <h2 id="同步遍历器的问题"><a href="#同步遍历器的问题" aria-hidden="true" class="header-anchor">#</a> 同步遍历器的问题</h2> <p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">idMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">next</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> index<span class="token operator">++</span><span class="token punctuation">,</span> done<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> it <span class="token operator">=</span> <span class="token function">idMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token comment">// 0</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token comment">// 1</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token comment">// 2</span>
<span class="token comment">// ...</span>
<span class="token comment">// 上面代码中，变量it是一个遍历器（iterator）。每次调用it.next()方法，就返回一个对象，表示当前遍历位置的信息。</span>

<span class="token comment">// 这里隐含着一个规定，it.next()方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行it.next()方法，就必须同步地得到value和done这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。</span>

<span class="token keyword">function</span> <span class="token function">idMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">next</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> index<span class="token operator">++</span><span class="token punctuation">,</span> done<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 上面代码中，next()方法返回的是一个 Promise 对象，这样就不行，不符合 Iterator 协议，只要代码里面包含异步操作都不行。也就是说，Iterator 协议里面next()方法只能包含同步操作。</span>

目前的解决方法是，将异步操作包装成 Thunk 函数或者 Promise <span class="token function">对象，即next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法返回值的value属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。

<span class="token keyword">function</span> <span class="token function">idMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">next</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        done<span class="token punctuation">:</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> it <span class="token operator">=</span> <span class="token function">idMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">o</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">o</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">o</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>
<span class="token comment">// ...</span>
上面代码中，value属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。

<span class="token constant">ES2018</span> 引入了“异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。

异步遍历的接口
异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。

asyncIterator
  <span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> value<span class="token punctuation">,</span> done <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token comment">/* ... */</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
上面代码中，asyncIterator是一个异步遍历器，调用next方法以后，返回一个 Promise 对象。因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。

我们知道，一个对象的同步遍历器的接口，部署在Symbol<span class="token punctuation">.</span>iterator属性上面。同样地，对象的异步遍历器接口，部署在Symbol<span class="token punctuation">.</span>asyncIterator属性上面。不管是什么样的对象，只要它的Symbol<span class="token punctuation">.</span>asyncIterator属性有值，就表示应该对它进行异步遍历。

下面是一个异步遍历器的例子。

<span class="token keyword">const</span> asyncIterable <span class="token operator">=</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> asyncIterator <span class="token operator">=</span> asyncIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

asyncIterator
<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">iterResult1</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterResult1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 'a', done: false }</span>
  <span class="token keyword">return</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">iterResult2</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterResult2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 'b', done: false }</span>
  <span class="token keyword">return</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">iterResult3</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterResult3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: undefined, done: true }</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象resolve了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。

由于异步遍历器的next方法，返回的是一个 Promise 对象。因此，可以把它放在<span class="token keyword">await</span>命令后面。

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> asyncIterable <span class="token operator">=</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> asyncIterator <span class="token operator">=</span> asyncIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// { value: 'a', done: false }</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// { value: 'b', done: false }</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// { value: undefined, done: true }</span>
<span class="token punctuation">}</span>
上面代码中，next方法用<span class="token keyword">await</span>处理以后，就不必使用then方法了。整个流程已经很接近同步处理了。

注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的 Promise 对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在Promise<span class="token punctuation">.</span>all方法里面。

<span class="token keyword">const</span> asyncIterable <span class="token operator">=</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> asyncIterator <span class="token operator">=</span> asyncIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>value<span class="token punctuation">:</span> v1<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token punctuation">:</span> v2<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  asyncIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a b</span>
另一种用法是一次性调用所有的next方法，然后<span class="token keyword">await</span>最后一步操作。

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> writer <span class="token operator">=</span> <span class="token function">openFile</span><span class="token punctuation">(</span><span class="token string">'someFile.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  writer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  writer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> writer<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of
前面介绍过，<span class="token keyword">for</span><span class="token operator">...</span>of循环用于遍历同步的 Iterator 接口。新引入的<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of循环，则是用于遍历异步的 Iterator 接口。

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> x <span class="token keyword">of</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// a</span>
<span class="token comment">// b</span>
<span class="token function">上面代码中，createAsyncIterable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回一个拥有异步遍历器接口的对象，<span class="token keyword">for</span><span class="token operator">...</span>of循环自动调用这个对象的异步遍历器的next方法，会得到一个 Promise 对象。<span class="token keyword">await</span>用来处理这个 Promise 对象，一旦resolve，就把得到的值（x）传入<span class="token keyword">for</span><span class="token operator">...</span>of的循环体。

<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。

<span class="token keyword">let</span> body <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span><span class="token punctuation">(</span><span class="token keyword">const</span> data <span class="token keyword">of</span> req<span class="token punctuation">)</span> body <span class="token operator">+=</span> data<span class="token punctuation">;</span>
  <span class="token keyword">const</span> parsed <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'got'</span><span class="token punctuation">,</span> parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上面代码中，req是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of循环以后，代码会非常简洁。

如果next方法返回的 Promise 对象被reject，<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of就会报错，要用<span class="token keyword">try</span><span class="token operator">...</span>catch捕捉。

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> x <span class="token keyword">of</span> <span class="token function">createRejectingIterable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
注意，<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span><span class="token function">of循环也可以用于同步遍历器。</span>

<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> x <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// a</span>
<span class="token comment">// b</span>
Node v10 支持异步遍历器，Stream 就部署了这个接口。下面是读取文件的传统写法与异步遍历器写法的差异。

<span class="token comment">// 传统写法</span>
<span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token parameter">inputFilePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> readStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>
    inputFilePath<span class="token punctuation">,</span>
    <span class="token punctuation">{</span> encoding<span class="token punctuation">:</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> highWaterMark<span class="token punctuation">:</span> <span class="token number">1024</span> <span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  readStream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'&gt;&gt;&gt; '</span><span class="token operator">+</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  readStream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'### DONE ###'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 异步遍历器写法</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token parameter">inputFilePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> readStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>
    inputFilePath<span class="token punctuation">,</span>
    <span class="token punctuation">{</span> encoding<span class="token punctuation">:</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> highWaterMark<span class="token punctuation">:</span> <span class="token number">1024</span> <span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chunk <span class="token keyword">of</span> readStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'&gt;&gt;&gt; '</span><span class="token operator">+</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'### DONE ###'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
异步 Generator 函数
就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。

在语法上，异步 Generator 函数就是<span class="token keyword">async</span>函数与 Generator 函数的结合。

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> genObj <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
genObj<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { value: 'hello', done: false }</span>
上面代码中，gen是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用next方法，返回一个 Promise 对象。

异步遍历器的设计目的之一，就是 Generator 函数处理同步操作和异步操作时，能够使用同一套接口。

<span class="token comment">// 同步 Generator 函数</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">iterable<span class="token punctuation">,</span> func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> iter <span class="token operator">=</span> iterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token function">func</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 异步 Generator 函数</span>
<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">iterable<span class="token punctuation">,</span> func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> iter <span class="token operator">=</span> iterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token function">func</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
上面代码中，map是一个 Generator 函数，第一个参数是可遍历对象iterable，第二个参数是一个回调函数func。map的作用是将iterable每一步返回的值，使用func进行处理。上面有两个版本的map，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。

下面是另一个异步 Generator 函数的例子。

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">readLines</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> file <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fileOpen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">yield</span> <span class="token keyword">await</span> file<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
上面代码中，异步操作前面使用<span class="token keyword">await</span>关键字标明，即<span class="token keyword">await</span>后面的操作，应该返回 Promise 对象。凡是使用<span class="token keyword">yield</span>关键字的地方，就是next方法停下来的地方，它后面的表达式的值（即<span class="token keyword">await</span> file<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">的值），会作为next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回对象的value属性，这一点是与同步 Generator 函数一致的。

异步 Generator 函数内部，能够同时使用<span class="token keyword">await</span>和<span class="token keyword">yield</span>命令。可以这样理解，<span class="token keyword">await</span>命令用于将外部操作产生的值输入函数内部，<span class="token keyword">yield</span>命令用于将函数内部的值输出。

上面代码定义的异步 Generator <span class="token function">函数的用法如下。</span>

<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> line <span class="token keyword">of</span> <span class="token function">readLines</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
异步 Generator 函数可以与<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of循环结合起来使用。

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">prefixLines</span><span class="token punctuation">(</span><span class="token parameter">asyncIterable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> line <span class="token keyword">of</span> asyncIterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token string">'&gt; '</span> <span class="token operator">+</span> line<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
异步 Generator 函数的返回值是一个异步 Iterator，即每次调用它的next方法，会返回一个 Promise 对象，也就是说，跟在<span class="token keyword">yield</span>命令后面的，应该是一个 Promise 对象。如果像上面那个例子那样，<span class="token keyword">yield</span>命令后面是一个字符串，会被自动包装成一个 Promise 对象。

<span class="token keyword">function</span> <span class="token function">fetchRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">'https://www.random.org/decimal-fractions/'</span>
    <span class="token operator">+</span> <span class="token string">'?num=1&amp;dec=10&amp;col=1&amp;format=plain&amp;rnd=new'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">asyncGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (A)</span>
  <span class="token keyword">yield</span> <span class="token string">'Result: '</span> <span class="token operator">+</span> <span class="token keyword">await</span> result<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (B)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> ag <span class="token operator">=</span> <span class="token function">asyncGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ag<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
上面代码中，ag是asyncGenerator函数返回的异步遍历器对象。调用ag<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>以后，上面代码的执行顺序如下。

ag<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>立刻返回一个 Promise 对象。
asyncGenerator函数开始执行，打印出Start。
<span class="token keyword">await</span>命令返回一个 Promise 对象，asyncGenerator函数停在这里。
<span class="token constant">A</span> 处变成 fulfilled 状态，产生的值放入result变量，asyncGenerator函数继续往下执行。
函数在 <span class="token constant">B</span> 处的<span class="token keyword">yield</span>暂停执行，一旦<span class="token keyword">yield</span>命令取到值，ag<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回的那个 Promise 对象变成 fulfilled 状态。
ag<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>后面的then方法指定的回调函数开始执行。该回调函数的参数是一个对象<span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span>，其中value的值是<span class="token keyword">yield</span>命令后面的那个表达式的值，done的值是<span class="token boolean">false</span>。
<span class="token constant">A</span> 和 <span class="token constant">B</span> 两行的作用类似于下面的代码。

<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">fetchRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> result<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
       value<span class="token punctuation">:</span> <span class="token string">'Result: '</span> <span class="token operator">+</span> result<span class="token punctuation">,</span>
       done<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
如果异步 Generator 函数抛出错误，会导致 Promise 对象的状态变为reject，然后抛出的错误被catch方法捕获。

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">asyncGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Problem!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">asyncGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: Problem!</span>
注意，普通的 <span class="token keyword">async</span> 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象。可以这样理解，<span class="token keyword">async</span> 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">takeAsync</span><span class="token punctuation">(</span><span class="token parameter">asyncIterable<span class="token punctuation">,</span> count <span class="token operator">=</span> <span class="token number">Infinity</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> iterator <span class="token operator">=</span> asyncIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上面代码中，异步 Generator 函数产生的异步遍历器，会通过<span class="token keyword">while</span>循环自动执行，每当<span class="token keyword">await</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>完成，就会进入下一轮循环。一旦done属性变为<span class="token boolean">true</span>，就会跳出循环，异步遍历器执行结束。

下面是这个自动执行器的一个使用实例。

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token string">'b'</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token string">'c'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token function">takeAsync</span><span class="token punctuation">(</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['a', 'b', 'c']</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、<span class="token keyword">async</span> 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用 <span class="token keyword">async</span> 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数。

异步 Generator 函数也可以通过next方法的参数，接收外部传入的数据。

<span class="token keyword">const</span> writer <span class="token operator">=</span> <span class="token function">openFile</span><span class="token punctuation">(</span><span class="token string">'someFile.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 立即执行</span>
writer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 立即执行</span>
<span class="token keyword">await</span> writer<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待写入结束</span>
上面代码中，openFile是一个异步 Generator 函数。next方法的参数，向该函数内部的操作传入数据。每次next方法都是同步执行的，最后的<span class="token keyword">await</span>命令用于等待整个写入操作结束。

最后，同步的数据结构，也可以使用异步 Generator 函数。

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token parameter">syncIterable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> elem <span class="token keyword">of</span> syncIterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> elem<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
上面代码中，由于没有异步操作，所以也就没有使用<span class="token keyword">await</span>关键字。

<span class="token keyword">yield</span><span class="token operator">*</span> 语句
<span class="token keyword">yield</span><span class="token operator">*</span>语句也可以跟一个异步遍历器。

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token string">'b'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// result 最终会等于 2</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token function">gen1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上面代码中，gen2函数里面的result变量，最后的值是<span class="token number">2</span>。

与同步 Generator 函数一样，<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token operator">...</span>of循环会展开<span class="token keyword">yield</span><span class="token operator">*</span><span class="token function">。</span>

<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> x <span class="token keyword">of</span> <span class="token function">gen2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// a</span>
<span class="token comment">// b</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/knowledge/assets/js/app.0598c8f5.js" defer></script><script src="/knowledge/assets/js/79.74931317.js" defer></script>
  </body>
</html>
