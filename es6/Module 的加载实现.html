<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Module 的加载实现 | oliveying</title>
    <meta name="description" content="前端知识，对前端遇到的问题进行总结">
    <link rel="icon" href="/knowledge/img/favicon.ico">
    
    <link rel="preload" href="/knowledge/assets/css/0.styles.ace1f307.css" as="style"><link rel="preload" href="/knowledge/assets/js/app.eebf957d.js" as="script"><link rel="preload" href="/knowledge/assets/js/62.9dc9d9b0.js" as="script"><link rel="prefetch" href="/knowledge/assets/js/10.bc04b720.js"><link rel="prefetch" href="/knowledge/assets/js/100.820557f8.js"><link rel="prefetch" href="/knowledge/assets/js/101.f860605a.js"><link rel="prefetch" href="/knowledge/assets/js/102.ba259878.js"><link rel="prefetch" href="/knowledge/assets/js/103.65709cfd.js"><link rel="prefetch" href="/knowledge/assets/js/104.59f12ae3.js"><link rel="prefetch" href="/knowledge/assets/js/105.500c1d83.js"><link rel="prefetch" href="/knowledge/assets/js/106.3ec1f20a.js"><link rel="prefetch" href="/knowledge/assets/js/107.e5904c31.js"><link rel="prefetch" href="/knowledge/assets/js/108.7fff76a4.js"><link rel="prefetch" href="/knowledge/assets/js/109.d05e98f1.js"><link rel="prefetch" href="/knowledge/assets/js/11.bc156b13.js"><link rel="prefetch" href="/knowledge/assets/js/110.2e849189.js"><link rel="prefetch" href="/knowledge/assets/js/111.4411281f.js"><link rel="prefetch" href="/knowledge/assets/js/112.94b79b3f.js"><link rel="prefetch" href="/knowledge/assets/js/113.160b4633.js"><link rel="prefetch" href="/knowledge/assets/js/114.178e2ae4.js"><link rel="prefetch" href="/knowledge/assets/js/115.2dc68bcb.js"><link rel="prefetch" href="/knowledge/assets/js/116.03e82432.js"><link rel="prefetch" href="/knowledge/assets/js/117.9b988c06.js"><link rel="prefetch" href="/knowledge/assets/js/118.b5fa4b07.js"><link rel="prefetch" href="/knowledge/assets/js/119.a371f9ae.js"><link rel="prefetch" href="/knowledge/assets/js/12.931677be.js"><link rel="prefetch" href="/knowledge/assets/js/120.4d455322.js"><link rel="prefetch" href="/knowledge/assets/js/121.3a16fd31.js"><link rel="prefetch" href="/knowledge/assets/js/122.dace177f.js"><link rel="prefetch" href="/knowledge/assets/js/123.6794c95c.js"><link rel="prefetch" href="/knowledge/assets/js/124.989c0c96.js"><link rel="prefetch" href="/knowledge/assets/js/125.91323bad.js"><link rel="prefetch" href="/knowledge/assets/js/126.f4011a1c.js"><link rel="prefetch" href="/knowledge/assets/js/127.e23396dc.js"><link rel="prefetch" href="/knowledge/assets/js/128.36327ae4.js"><link rel="prefetch" href="/knowledge/assets/js/129.e67d4505.js"><link rel="prefetch" href="/knowledge/assets/js/13.526f89dd.js"><link rel="prefetch" href="/knowledge/assets/js/130.5caf191e.js"><link rel="prefetch" href="/knowledge/assets/js/131.57b1affa.js"><link rel="prefetch" href="/knowledge/assets/js/132.609f328a.js"><link rel="prefetch" href="/knowledge/assets/js/133.76cbc727.js"><link rel="prefetch" href="/knowledge/assets/js/134.14c6af99.js"><link rel="prefetch" href="/knowledge/assets/js/135.8d46e7b5.js"><link rel="prefetch" href="/knowledge/assets/js/136.7393ddfc.js"><link rel="prefetch" href="/knowledge/assets/js/137.47699256.js"><link rel="prefetch" href="/knowledge/assets/js/138.a3386983.js"><link rel="prefetch" href="/knowledge/assets/js/139.044fb02c.js"><link rel="prefetch" href="/knowledge/assets/js/14.d6a2386d.js"><link rel="prefetch" href="/knowledge/assets/js/140.bfdbb628.js"><link rel="prefetch" href="/knowledge/assets/js/141.12ef5cb3.js"><link rel="prefetch" href="/knowledge/assets/js/142.9b859bf0.js"><link rel="prefetch" href="/knowledge/assets/js/143.c920117e.js"><link rel="prefetch" href="/knowledge/assets/js/144.d72a93f1.js"><link rel="prefetch" href="/knowledge/assets/js/145.bb1382e9.js"><link rel="prefetch" href="/knowledge/assets/js/146.ed9791b2.js"><link rel="prefetch" href="/knowledge/assets/js/147.91a68c89.js"><link rel="prefetch" href="/knowledge/assets/js/148.a601b23e.js"><link rel="prefetch" href="/knowledge/assets/js/149.8b80e5f3.js"><link rel="prefetch" href="/knowledge/assets/js/15.74572eea.js"><link rel="prefetch" href="/knowledge/assets/js/150.eab410af.js"><link rel="prefetch" href="/knowledge/assets/js/151.8530e27c.js"><link rel="prefetch" href="/knowledge/assets/js/152.a0f7836e.js"><link rel="prefetch" href="/knowledge/assets/js/153.9c9a29bb.js"><link rel="prefetch" href="/knowledge/assets/js/154.e8817fcf.js"><link rel="prefetch" href="/knowledge/assets/js/155.b92a2c40.js"><link rel="prefetch" href="/knowledge/assets/js/156.3dd19eae.js"><link rel="prefetch" href="/knowledge/assets/js/157.4e891369.js"><link rel="prefetch" href="/knowledge/assets/js/158.c7805ffe.js"><link rel="prefetch" href="/knowledge/assets/js/159.3e07b196.js"><link rel="prefetch" href="/knowledge/assets/js/16.3d09273f.js"><link rel="prefetch" href="/knowledge/assets/js/160.ff57a617.js"><link rel="prefetch" href="/knowledge/assets/js/161.9e884cc7.js"><link rel="prefetch" href="/knowledge/assets/js/162.460a3898.js"><link rel="prefetch" href="/knowledge/assets/js/163.31dfff55.js"><link rel="prefetch" href="/knowledge/assets/js/164.0393da42.js"><link rel="prefetch" href="/knowledge/assets/js/165.dd410874.js"><link rel="prefetch" href="/knowledge/assets/js/166.c1fb6844.js"><link rel="prefetch" href="/knowledge/assets/js/167.8579a58f.js"><link rel="prefetch" href="/knowledge/assets/js/168.a08ed75c.js"><link rel="prefetch" href="/knowledge/assets/js/169.2ff27854.js"><link rel="prefetch" href="/knowledge/assets/js/17.1cd6b989.js"><link rel="prefetch" href="/knowledge/assets/js/170.7d89bb98.js"><link rel="prefetch" href="/knowledge/assets/js/171.180b4310.js"><link rel="prefetch" href="/knowledge/assets/js/172.0194594d.js"><link rel="prefetch" href="/knowledge/assets/js/173.fdfe3992.js"><link rel="prefetch" href="/knowledge/assets/js/174.da9fb517.js"><link rel="prefetch" href="/knowledge/assets/js/18.b472874f.js"><link rel="prefetch" href="/knowledge/assets/js/19.519eeb36.js"><link rel="prefetch" href="/knowledge/assets/js/2.4277b334.js"><link rel="prefetch" href="/knowledge/assets/js/20.71bbb4dd.js"><link rel="prefetch" href="/knowledge/assets/js/21.ed46fe08.js"><link rel="prefetch" href="/knowledge/assets/js/22.7586bec6.js"><link rel="prefetch" href="/knowledge/assets/js/23.3b8a3e4f.js"><link rel="prefetch" href="/knowledge/assets/js/24.a76b5f2b.js"><link rel="prefetch" href="/knowledge/assets/js/25.a9b7ed33.js"><link rel="prefetch" href="/knowledge/assets/js/26.45bedfeb.js"><link rel="prefetch" href="/knowledge/assets/js/27.60f34284.js"><link rel="prefetch" href="/knowledge/assets/js/28.269fb6ad.js"><link rel="prefetch" href="/knowledge/assets/js/29.d94aad0b.js"><link rel="prefetch" href="/knowledge/assets/js/3.2c14a60e.js"><link rel="prefetch" href="/knowledge/assets/js/30.ffdd8fcc.js"><link rel="prefetch" href="/knowledge/assets/js/31.da22b354.js"><link rel="prefetch" href="/knowledge/assets/js/32.fb84698a.js"><link rel="prefetch" href="/knowledge/assets/js/33.106f4b5e.js"><link rel="prefetch" href="/knowledge/assets/js/34.6bf79fca.js"><link rel="prefetch" href="/knowledge/assets/js/35.e3e3d5f0.js"><link rel="prefetch" href="/knowledge/assets/js/36.202014e5.js"><link rel="prefetch" href="/knowledge/assets/js/37.9a658e5a.js"><link rel="prefetch" href="/knowledge/assets/js/38.5e07db2d.js"><link rel="prefetch" href="/knowledge/assets/js/39.b9b1729a.js"><link rel="prefetch" href="/knowledge/assets/js/4.0c9cd7fa.js"><link rel="prefetch" href="/knowledge/assets/js/40.a7237a56.js"><link rel="prefetch" href="/knowledge/assets/js/41.c9c1fd5a.js"><link rel="prefetch" href="/knowledge/assets/js/42.22b48a05.js"><link rel="prefetch" href="/knowledge/assets/js/43.199b3d09.js"><link rel="prefetch" href="/knowledge/assets/js/44.d7abf9cd.js"><link rel="prefetch" href="/knowledge/assets/js/45.002a2b60.js"><link rel="prefetch" href="/knowledge/assets/js/46.d045c627.js"><link rel="prefetch" href="/knowledge/assets/js/47.ea863d39.js"><link rel="prefetch" href="/knowledge/assets/js/48.144ed240.js"><link rel="prefetch" href="/knowledge/assets/js/49.e99981b9.js"><link rel="prefetch" href="/knowledge/assets/js/5.18b09f48.js"><link rel="prefetch" href="/knowledge/assets/js/50.af00a3a4.js"><link rel="prefetch" href="/knowledge/assets/js/51.e33c86c1.js"><link rel="prefetch" href="/knowledge/assets/js/52.f4b55fc8.js"><link rel="prefetch" href="/knowledge/assets/js/53.b9704404.js"><link rel="prefetch" href="/knowledge/assets/js/54.24f7bf20.js"><link rel="prefetch" href="/knowledge/assets/js/55.41b186a1.js"><link rel="prefetch" href="/knowledge/assets/js/56.ce42e0a9.js"><link rel="prefetch" href="/knowledge/assets/js/57.71e8d12c.js"><link rel="prefetch" href="/knowledge/assets/js/58.5aa9c60e.js"><link rel="prefetch" href="/knowledge/assets/js/59.f3a25cb8.js"><link rel="prefetch" href="/knowledge/assets/js/6.44f2b87d.js"><link rel="prefetch" href="/knowledge/assets/js/60.887c39d1.js"><link rel="prefetch" href="/knowledge/assets/js/61.e39675d1.js"><link rel="prefetch" href="/knowledge/assets/js/63.cb8752d6.js"><link rel="prefetch" href="/knowledge/assets/js/64.fa36d461.js"><link rel="prefetch" href="/knowledge/assets/js/65.c8b2e590.js"><link rel="prefetch" href="/knowledge/assets/js/66.223c4711.js"><link rel="prefetch" href="/knowledge/assets/js/67.257068da.js"><link rel="prefetch" href="/knowledge/assets/js/68.4d624e56.js"><link rel="prefetch" href="/knowledge/assets/js/69.3839ef6c.js"><link rel="prefetch" href="/knowledge/assets/js/7.95f897d3.js"><link rel="prefetch" href="/knowledge/assets/js/70.a0b53c58.js"><link rel="prefetch" href="/knowledge/assets/js/71.8db16ae8.js"><link rel="prefetch" href="/knowledge/assets/js/72.1824b647.js"><link rel="prefetch" href="/knowledge/assets/js/73.f5cab150.js"><link rel="prefetch" href="/knowledge/assets/js/74.04b4fe76.js"><link rel="prefetch" href="/knowledge/assets/js/75.294dac12.js"><link rel="prefetch" href="/knowledge/assets/js/76.68cba487.js"><link rel="prefetch" href="/knowledge/assets/js/77.b5cbf564.js"><link rel="prefetch" href="/knowledge/assets/js/78.3445959c.js"><link rel="prefetch" href="/knowledge/assets/js/79.2bf972e4.js"><link rel="prefetch" href="/knowledge/assets/js/8.69088bf5.js"><link rel="prefetch" href="/knowledge/assets/js/80.a8589313.js"><link rel="prefetch" href="/knowledge/assets/js/81.c0d072e1.js"><link rel="prefetch" href="/knowledge/assets/js/82.e260f019.js"><link rel="prefetch" href="/knowledge/assets/js/83.4969e1a3.js"><link rel="prefetch" href="/knowledge/assets/js/84.00d0422e.js"><link rel="prefetch" href="/knowledge/assets/js/85.80e1dbc2.js"><link rel="prefetch" href="/knowledge/assets/js/86.6c9bcf72.js"><link rel="prefetch" href="/knowledge/assets/js/87.cd563e06.js"><link rel="prefetch" href="/knowledge/assets/js/88.5e64258b.js"><link rel="prefetch" href="/knowledge/assets/js/89.9ee006c5.js"><link rel="prefetch" href="/knowledge/assets/js/9.f7f1342e.js"><link rel="prefetch" href="/knowledge/assets/js/90.b47778b1.js"><link rel="prefetch" href="/knowledge/assets/js/91.e2e46466.js"><link rel="prefetch" href="/knowledge/assets/js/92.751f7222.js"><link rel="prefetch" href="/knowledge/assets/js/93.ff8e7884.js"><link rel="prefetch" href="/knowledge/assets/js/94.a110704d.js"><link rel="prefetch" href="/knowledge/assets/js/95.86a6f24a.js"><link rel="prefetch" href="/knowledge/assets/js/96.1bb1a8d7.js"><link rel="prefetch" href="/knowledge/assets/js/97.a25595b7.js"><link rel="prefetch" href="/knowledge/assets/js/98.98925b82.js"><link rel="prefetch" href="/knowledge/assets/js/99.3415a21d.js">
    <link rel="stylesheet" href="/knowledge/assets/css/0.styles.ace1f307.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/knowledge/" class="home-link router-link-active"><!----> <span class="site-name">oliveying</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/knowledge/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">book</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/bgoodparts/" class="nav-link">语言精粹</a></li><li class="dropdown-item"><!----> <a href="/knowledge/http/" class="nav-link">图解http</a></li><li class="dropdown-item"><!----> <a href="/knowledge/es6/" class="nav-link router-link-active">es6</a></li><li class="dropdown-item"><!----> <a href="/knowledge/javascript/" class="nav-link">javascript教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/html/" class="nav-link">html</a></li><li class="dropdown-item"><!----> <a href="/knowledge/css/" class="nav-link">css</a></li><li class="dropdown-item"><!----> <a href="/knowledge/js/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/knowledge/jsHigh/" class="nav-link">javascriptHigh</a></li><li class="dropdown-item"><!----> <a href="/knowledge/h5/" class="nav-link">h5最新用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/knowledge/brower/" class="nav-link">浏览器特性</a></li><li class="dropdown-item"><!----> <a href="/knowledge/d3/" class="nav-link">d3</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">总结</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/summary/" class="nav-link">总结</a></li><li class="dropdown-item"><!----> <a href="/knowledge/interview/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/knowledge/problem/" class="nav-link">problem</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">扩展</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/start/" class="nav-link">启动</a></li><li class="dropdown-item"><!----> <a href="/knowledge/tool/" class="nav-link">工具用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/markdown/" class="nav-link">markDown</a></li><li class="dropdown-item"><!----> <a href="/knowledge/linux/" class="nav-link">linux</a></li><li class="dropdown-item"><!----> <a href="/knowledge/mac/" class="nav-link">mac</a></li><li class="dropdown-item"><!----> <a href="/knowledge/develop/" class="nav-link">提升</a></li><li class="dropdown-item"><!----> <a href="/knowledge/redis/" class="nav-link">redis</a></li></ul></div></div> <a href="https://github.com/oliveying/knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/knowledge/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">book</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/bgoodparts/" class="nav-link">语言精粹</a></li><li class="dropdown-item"><!----> <a href="/knowledge/http/" class="nav-link">图解http</a></li><li class="dropdown-item"><!----> <a href="/knowledge/es6/" class="nav-link router-link-active">es6</a></li><li class="dropdown-item"><!----> <a href="/knowledge/javascript/" class="nav-link">javascript教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/html/" class="nav-link">html</a></li><li class="dropdown-item"><!----> <a href="/knowledge/css/" class="nav-link">css</a></li><li class="dropdown-item"><!----> <a href="/knowledge/js/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/knowledge/jsHigh/" class="nav-link">javascriptHigh</a></li><li class="dropdown-item"><!----> <a href="/knowledge/h5/" class="nav-link">h5最新用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/knowledge/brower/" class="nav-link">浏览器特性</a></li><li class="dropdown-item"><!----> <a href="/knowledge/d3/" class="nav-link">d3</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">总结</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/summary/" class="nav-link">总结</a></li><li class="dropdown-item"><!----> <a href="/knowledge/interview/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/knowledge/problem/" class="nav-link">problem</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">扩展</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/knowledge/start/" class="nav-link">启动</a></li><li class="dropdown-item"><!----> <a href="/knowledge/tool/" class="nav-link">工具用法</a></li><li class="dropdown-item"><!----> <a href="/knowledge/markdown/" class="nav-link">markDown</a></li><li class="dropdown-item"><!----> <a href="/knowledge/linux/" class="nav-link">linux</a></li><li class="dropdown-item"><!----> <a href="/knowledge/mac/" class="nav-link">mac</a></li><li class="dropdown-item"><!----> <a href="/knowledge/develop/" class="nav-link">提升</a></li><li class="dropdown-item"><!----> <a href="/knowledge/redis/" class="nav-link">redis</a></li></ul></div></div> <a href="https://github.com/oliveying/knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/knowledge/es6/let和const.html" class="sidebar-link">es6 let const</a></li><li><a href="/knowledge/es6/变量的解构赋值.html" class="sidebar-link">变量的解构赋值</a></li><li><a href="/knowledge/es6/字符串的扩展.html" class="sidebar-link">字符串的扩展</a></li><li><a href="/knowledge/es6/字符串的新增方法.html" class="sidebar-link">String.fromCodePoint()</a></li><li><a href="/knowledge/es6/正则的扩展.html" class="sidebar-link">正则的扩展</a></li><li><a href="/knowledge/es6/数值的扩展.html" class="sidebar-link">数值的扩展</a></li><li><a href="/knowledge/es6/函数的扩展.html" class="sidebar-link">函数的扩展</a></li><li><a href="/knowledge/es6/对象的扩展.html" class="sidebar-link">对象的扩展</a></li><li><a href="/knowledge/es6/对象的新增方法.html" class="sidebar-link">对象的新增方法</a></li><li><a href="/knowledge/es6/symbol.html" class="sidebar-link">Symbol</a></li><li><a href="/knowledge/es6/set和map数据结构.html" class="sidebar-link">set 和 map 数据结构</a></li><li><a href="/knowledge/es6/proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/knowledge/es6/reflect.html" class="sidebar-link">reflect</a></li><li><a href="/knowledge/es6/Promise对象.html" class="sidebar-link">Promise</a></li><li><a href="/knowledge/es6/Iterator和for...of循环.html" class="sidebar-link">Iterator和for...of循环</a></li><li><a href="/knowledge/es6/Generator函数的语法.html" class="sidebar-link">Generator函数的语法</a></li><li><a href="/knowledge/es6/Generator函数的异步应用.html" class="sidebar-link">Generator函数的异步应用</a></li><li><a href="/knowledge/es6/Async.html" class="sidebar-link">Async</a></li><li><a href="/knowledge/es6/Class的基本语法.html" class="sidebar-link">Class的基本语法</a></li><li><a href="/knowledge/es6/Class的继承.html" class="sidebar-link">Class的继承</a></li><li><a href="/knowledge/es6/Module的语法.html" class="sidebar-link">Module的语法</a></li><li><a href="/knowledge/es6/Module 的加载实现.html" class="active sidebar-link">Module 的加载实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#浏览器加载" class="sidebar-link">浏览器加载</a></li><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#加载规则" class="sidebar-link">加载规则</a></li><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#es6-模块与-commonjs-模块的差异" class="sidebar-link">ES6 模块与 CommonJS 模块的差异</a></li><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#node-加载" class="sidebar-link">Node 加载</a></li><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#es6-模块加载-commonjs-模块" class="sidebar-link">ES6 模块加载 CommonJS 模块</a></li><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#commonjs-模块加载-es6-模块" class="sidebar-link">CommonJS 模块加载 ES6 模块</a></li><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#循环加载" class="sidebar-link">循环加载</a></li><li class="sidebar-sub-header"><a href="/knowledge/es6/Module 的加载实现.html#es6-模块的转码" class="sidebar-link">ES6 模块的转码</a></li></ul></li><li><a href="/knowledge/es6/编程风格.html" class="sidebar-link">编程风格</a></li><li><a href="/knowledge/es6/读懂ECMAScript规格.html" class="sidebar-link">读懂ECMAScript规格</a></li><li><a href="/knowledge/es6/异步遍历器.html" class="sidebar-link">异步遍历器</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="module-的加载实现"><a href="#module-的加载实现" aria-hidden="true" class="header-anchor">#</a> Module 的加载实现</h1> <p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p> <h2 id="浏览器加载"><a href="#浏览器加载" aria-hidden="true" class="header-anchor">#</a> 浏览器加载</h2> <h3 id="传统方法"><a href="#传统方法" aria-hidden="true" class="header-anchor">#</a> 传统方法</h3> <p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 页面内嵌的脚本 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>application/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token comment">// module code</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 外部脚本 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>application/javascript<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>path/to/myModule.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=&quot;application/javascript&quot;可以省略。</p> <p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p> <p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>path/to/myModule.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">defer</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>path/to/myModule.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">async</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面代码中，<code>&lt;script&gt;</code>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p> <p>defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p> <h2 id="加载规则"><a href="#加载规则" aria-hidden="true" class="header-anchor">#</a> 加载规则</h2> <p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入type=&quot;module&quot;属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;./foo.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。</span>

<span class="token comment">// 浏览器对于带有type=&quot;module&quot;的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。</span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;./foo.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// &lt;!-- 等同于 --&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;./foo.js&quot;</span> defer<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 如果网页有多个&lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。</span>

<span class="token comment">// &lt;script&gt;标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;./foo.js&quot;</span> async<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 一旦使用了async属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</span>

<span class="token comment">// ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span>
  <span class="token keyword">import</span> utils <span class="token keyword">from</span> <span class="token string">&quot;./utils.js&quot;</span><span class="token punctuation">;</span>

  <span class="token comment">// other code</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 举例来说，jQuery 就支持模块加载。</span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span>
  <span class="token keyword">import</span> $ <span class="token keyword">from</span> <span class="token string">&quot;./jquery/src/jquery.js&quot;</span><span class="token punctuation">;</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#message'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">'Hi from jQuery!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>对于外部的模块脚本（上例是foo.js），有几点需要注意。</p> <ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li> <li>模块脚本自动采用严格模式，不管有没有声明use strict。</li> <li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li> <li>模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</li> <li>同一个模块如果加载多次，将只执行一次。
下面是一个示例模块。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> utils <span class="token keyword">from</span> <span class="token string">'https://example.com/js/utils.js'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">===</span> window<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。</span>

<span class="token keyword">const</span> isNotModuleScript <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="es6-模块与-commonjs-模块的差异"><a href="#es6-模块与-commonjs-模块的差异" aria-hidden="true" class="header-anchor">#</a> ES6 模块与 CommonJS 模块的差异</h2> <p>讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p> <p>它们有两个重大差异。</p> <ol><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li> <li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ol> <p>下面重点解释第一个差异。</p> <p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// lib.js</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  counter<span class="token punctuation">:</span> counter<span class="token punctuation">,</span>
  incCounter<span class="token punctuation">:</span> incCounter<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。</span>

<span class="token comment">// main.js</span>
<span class="token keyword">var</span> mod <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./lib'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span>
mod<span class="token punctuation">.</span><span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token comment">// 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</span>

<span class="token comment">// lib.js</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> counter
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  incCounter<span class="token punctuation">:</span> incCounter<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</span>

$ node main<span class="token punctuation">.</span>js
<span class="token number">3</span>
<span class="token number">4</span>
<span class="token comment">// ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span>

<span class="token comment">// 还是举上面的例子。</span>

<span class="token comment">// lib.js</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> counter<span class="token punctuation">,</span> incCounter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./lib'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
<span class="token comment">// 上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。</span>

<span class="token comment">// 再举一个出现在export一节中的例子。</span>

<span class="token comment">// m1.js</span>
<span class="token keyword">export</span> <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> foo <span class="token operator">=</span> <span class="token string">'baz'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// m2.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>foo<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./m1.js'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。</span>

<span class="token comment">// 让我们看看，m2.js能否正确读取这个变化。</span>
$ babel<span class="token operator">-</span>node m2<span class="token punctuation">.</span>js

bar
baz
<span class="token comment">// 上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</span>

<span class="token comment">// 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</span>

<span class="token comment">// lib.js</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> obj <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./lib'</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// TypeError</span>
<span class="token comment">// 上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。</span>

<span class="token comment">// 最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</span>

<span class="token comment">// mod.js</span>
<span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sum <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">show</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。</span>

<span class="token comment">// x.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>c<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./mod'</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// y.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>c<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./mod'</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// main.js</span>
<span class="token keyword">import</span> <span class="token string">'./x'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'./y'</span><span class="token punctuation">;</span>
<span class="token comment">// 现在执行main.js，输出的是1。</span>

$ babel<span class="token operator">-</span>node main<span class="token punctuation">.</span>js
<span class="token number">1</span>
<span class="token comment">// 这就证明了x.js和y.js加载的都是C的同一个实例。</span>
</code></pre></div><h2 id="node-加载"><a href="#node-加载" aria-hidden="true" class="header-anchor">#</a> Node 加载</h2> <h3 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h3> <p>Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。</p> <p>Node 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。</p> <p>目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用--experimental-modules参数才能打开该功能。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ node --experimental-modules my-app.mjs
<span class="token comment"># 为了与浏览器的import加载规则相同，Node 的.mjs文件支持 URL 路径。</span>

<span class="token function">import</span> <span class="token string">'./foo?query=1'</span><span class="token punctuation">;</span> <span class="token comment"># 加载 ./foo 传入参数 ?query=1</span>
<span class="token comment"># 上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。</span>

<span class="token comment"># 目前，Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。</span>

<span class="token comment"># 如果模块名不含路径，那么import命令会去node_modules目录寻找这个模块。</span>

<span class="token function">import</span> <span class="token string">'baz'</span><span class="token punctuation">;</span>
<span class="token function">import</span> <span class="token string">'abc/123'</span><span class="token punctuation">;</span>
<span class="token comment"># 如果模块名包含路径，那么import命令会按照路径去寻找这个名字的脚本文件。</span>

<span class="token function">import</span> <span class="token string">'file:///etc/config/app.json'</span><span class="token punctuation">;</span>
<span class="token function">import</span> <span class="token string">'./foo'</span><span class="token punctuation">;</span>
<span class="token function">import</span> <span class="token string">'./foo?search'</span><span class="token punctuation">;</span>
<span class="token function">import</span> <span class="token string">'../bar'</span><span class="token punctuation">;</span>
<span class="token function">import</span> <span class="token string">'/baz'</span><span class="token punctuation">;</span>
<span class="token comment"># 如果脚本文件省略了后缀名，比如import './foo'，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。</span>

<span class="token comment"># 最后，Node 的import命令是异步加载，这一点与浏览器的处理方法相同。</span>
</code></pre></div><h3 id="内部变量"><a href="#内部变量" aria-hidden="true" class="header-anchor">#</a> 内部变量</h3> <p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p> <p>首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。</p> <p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p> <div class="language-js extra-class"><pre class="language-js"><code>arguments
require
module
exports
__filename
__dirname
</code></pre></div><p>如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// expose.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>__dirname<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// use.mjs</span>
<span class="token keyword">import</span> expose <span class="token keyword">from</span> <span class="token string">'./expose.js'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span>__dirname<span class="token punctuation">}</span> <span class="token operator">=</span> expose<span class="token punctuation">;</span>
<span class="token comment">// 上面代码中，expose.js是一个 CommonJS 模块，输出变量__dirname，该变量在 ES6 模块之中不存在。ES6 模块加载expose.js，就可以得到__dirname。</span>
</code></pre></div><h2 id="es6-模块加载-commonjs-模块"><a href="#es6-模块加载-commonjs-模块" aria-hidden="true" class="header-anchor">#</a> ES6 模块加载 CommonJS 模块</h2> <p>CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p> <p>下面是一个 CommonJS 模块。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  foo<span class="token punctuation">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>
  bar<span class="token punctuation">:</span> <span class="token string">'world'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 等同于</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  foo<span class="token punctuation">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>
  bar<span class="token punctuation">:</span> <span class="token string">'world'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// import命令加载上面的模块，module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }。</span>

<span class="token comment">// 所以，一共有三种写法，可以拿到 CommonJS 模块的module.exports。</span>

<span class="token comment">// 写法一</span>
<span class="token keyword">import</span> baz <span class="token keyword">from</span> <span class="token string">'./a'</span><span class="token punctuation">;</span>
<span class="token comment">// baz = {foo: 'hello', bar: 'world'};</span>

<span class="token comment">// 写法二</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span><span class="token keyword">default</span> <span class="token keyword">as</span> baz<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./a'</span><span class="token punctuation">;</span>
<span class="token comment">// baz = {foo: 'hello', bar: 'world'};</span>

<span class="token comment">// 写法三</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> baz <span class="token keyword">from</span> <span class="token string">'./a'</span><span class="token punctuation">;</span>
<span class="token comment">// baz = {</span>
<span class="token comment">//   get default() {return module.exports;},</span>
<span class="token comment">//   get foo() {return this.default.foo}.bind(baz),</span>
<span class="token comment">//   get bar() {return this.default.bar}.bind(baz)</span>
<span class="token comment">// }</span>
<span class="token comment">// 上面代码的第三种写法，可以通过baz.default拿到module.exports。foo属性和bar属性就是可以通过这种方法拿到了module.exports。</span>

<span class="token comment">// 下面是一些例子。</span>

<span class="token comment">// b.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token comment">// es.js</span>
<span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">'./b'</span><span class="token punctuation">;</span>
<span class="token comment">// foo = null;</span>

<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> bar <span class="token keyword">from</span> <span class="token string">'./b'</span><span class="token punctuation">;</span>
<span class="token comment">// bar = { default:null };</span>
<span class="token comment">// 上面代码中，es.js采用第二种写法时，要通过bar.default这样的写法，才能拿到module.exports。</span>

<span class="token comment">// c.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// es.js</span>
<span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">'./c'</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> bar <span class="token keyword">from</span> <span class="token string">'./c'</span><span class="token punctuation">;</span>
bar<span class="token punctuation">.</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throws, bar is not a function</span>
<span class="token comment">// 上面代码中，bar本身是一个对象，不能当作函数调用，只能通过bar.default调用。</span>

<span class="token comment">// CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。</span>

<span class="token comment">// foo.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码中，对于加载foo.js的脚本，module.exports将一直是123，而不会变成null。</span>

<span class="token comment">// 由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用import命令加载 CommonJS 模块时，不允许采用下面的写法。</span>

<span class="token comment">// 不正确</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> readFile <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'fs'</span><span class="token punctuation">;</span>
<span class="token comment">// 上面的写法不正确，因为fs是 CommonJS 格式，只有在运行时才能确定readFile接口，而import命令要求编译时就确定这个接口。解决方法就是改为整体输入。</span>

<span class="token comment">// 正确的写法一</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> express <span class="token keyword">from</span> <span class="token string">'express'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 正确的写法二</span>
<span class="token keyword">import</span> express <span class="token keyword">from</span> <span class="token string">'express'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="commonjs-模块加载-es6-模块"><a href="#commonjs-模块加载-es6-模块" aria-hidden="true" class="header-anchor">#</a> CommonJS 模块加载 ES6 模块</h2> <p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// es.mjs</span>
<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token punctuation">:</span> <span class="token string">'my-default'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> foo<span class="token punctuation">;</span>

<span class="token comment">// cjs.js</span>
<span class="token keyword">const</span> es_namespace <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./es.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// es_namespace = {</span>
<span class="token comment">//   get default() {</span>
<span class="token comment">//     ...</span>
<span class="token comment">//   }</span>
<span class="token comment">// }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>es_namespace<span class="token punctuation">.</span>default<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { bar:'my-default' }</span>
<span class="token comment">// 上面代码中，default接口变成了es_namespace.default属性。</span>

<span class="token comment">// 下面是另一个例子。</span>

<span class="token comment">// es.js</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token punctuation">:</span><span class="token string">'my-default'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> bar <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">c</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// cjs.js</span>
<span class="token keyword">const</span> es_namespace <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./es'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// es_namespace = {</span>
<span class="token comment">//   get foo() {return foo;}</span>
<span class="token comment">//   get bar() {return foo;}</span>
<span class="token comment">//   get f() {return f;}</span>
<span class="token comment">//   get c() {return c;}</span>
<span class="token comment">// }</span>
</code></pre></div><h2 id="循环加载"><a href="#循环加载" aria-hidden="true" class="header-anchor">#</a> 循环加载</h2> <p>“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.js</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// b.js</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</span>

<span class="token comment">// 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</span>
</code></pre></div><p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p> <h3 id="commonjs-模块的加载原理"><a href="#commonjs-模块的加载原理" aria-hidden="true" class="header-anchor">#</a> CommonJS 模块的加载原理</h3> <p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p> <p>CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span>
  exports<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  loaded<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p> <p>以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p> <h3 id="commonjs-模块的循环加载"><a href="#commonjs-模块的循环加载" aria-hidden="true" class="header-anchor">#</a> CommonJS 模块的循环加载</h3> <p>CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被&quot;循环加载&quot;，就只输出已经执行的部分，还未执行的部分不会输出。</p> <p>让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。</p> <div class="language-js extra-class"><pre class="language-js"><code>exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'在 a.js 之中，b.done = %j'</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.js 执行完毕'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。</span>

<span class="token comment">// 再看b.js的代码。</span>

exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'在 b.js 之中，a.done = %j'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b.js 执行完毕'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。</span>

<span class="token comment">// a.js已经执行的部分，只有一行。</span>

exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment">// 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。</span>

<span class="token comment">// 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'在 main.js 之中, a.done=%j, b.done=%j'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>done<span class="token punctuation">,</span> b<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 执行main.js，运行结果如下。</span>

$ node main<span class="token punctuation">.</span>js

<span class="token comment">// 在 b.js 之中，a.done = false</span>
<span class="token comment">// b.js 执行完毕</span>
<span class="token comment">// 在 a.js 之中，b.done = true</span>
<span class="token comment">// a.js 执行完毕</span>
<span class="token comment">// 在 main.js 之中, a.done=true, b.done=true</span>
<span class="token comment">// 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。</span>

exports<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token comment">// 总之，CommonJS 输入的是被输出值的拷贝，不是引用。</span>

<span class="token comment">// 另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 安全的写法</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// 危险的写法</span>

exports<span class="token punctuation">.</span><span class="token function-variable function">good</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'good'</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用的是 a.foo 的最新值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

exports<span class="token punctuation">.</span><span class="token function-variable function">bad</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'bad'</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用的是一个部分加载时的值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码中，如果发生循环加载，require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。</span>
</code></pre></div><h3 id="es6-模块的循环加载"><a href="#es6-模块的循环加载" aria-hidden="true" class="header-anchor">#</a> ES6 模块的循环加载</h3> <p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p> <p>请看下面这个例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.mjs</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>bar<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./b'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>

<span class="token comment">// b.mjs</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>foo<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./a'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。</span>

$ node <span class="token operator">--</span>experimental<span class="token operator">-</span>modules a<span class="token punctuation">.</span>mjs
b<span class="token punctuation">.</span>mjs
<span class="token comment">// ReferenceError: foo is not defined</span>
<span class="token comment">// 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？</span>

<span class="token comment">// 让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。</span>

<span class="token comment">// 解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。</span>

<span class="token comment">// a.mjs</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>bar<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./b'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>foo<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// b.mjs</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>foo<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./a'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>bar<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 这时再执行a.mjs就可以得到预期结果。</span>

$ node <span class="token operator">--</span>experimental<span class="token operator">-</span>modules a<span class="token punctuation">.</span>mjs
b<span class="token punctuation">.</span>mjs
foo
a<span class="token punctuation">.</span>mjs
bar
<span class="token comment">// 这是因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。</span>

<span class="token comment">// a.mjs</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>bar<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./b'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>foo<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</span>

<span class="token comment">// 我们再来看 ES6 模块加载器SystemJS给出的一个例子。</span>

<span class="token comment">// even.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> odd <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./odd'</span>
<span class="token keyword">export</span> <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">even</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> n <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">odd</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// odd.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> even <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./even'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">odd</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">even</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。</span>

<span class="token comment">// 运行上面这段代码，结果如下。</span>

$ babel<span class="token operator">-</span>node
<span class="token operator">&gt;</span> <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> m <span class="token keyword">from</span> <span class="token string">'./even.js'</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> m<span class="token punctuation">.</span><span class="token function">even</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token boolean">true</span>
<span class="token operator">&gt;</span> m<span class="token punctuation">.</span>counter
<span class="token number">6</span>
<span class="token operator">&gt;</span> m<span class="token punctuation">.</span><span class="token function">even</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>
<span class="token operator">&gt;</span> m<span class="token punctuation">.</span>counter
<span class="token number">17</span>
<span class="token comment">// 上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于 6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。</span>

<span class="token comment">// 这个例子要是改写成 CommonJS，就根本无法执行，会报错。</span>

<span class="token comment">// even.js</span>
<span class="token keyword">var</span> odd <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./odd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>counter <span class="token operator">=</span> counter<span class="token punctuation">;</span>
exports<span class="token punctuation">.</span><span class="token function-variable function">even</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">odd</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// odd.js</span>
<span class="token keyword">var</span> even <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./even'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>even<span class="token punctuation">;</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">even</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于undefined，等到后面调用even(n - 1)就会报错。</span>

$ node
<span class="token operator">&gt;</span> <span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./even'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> m<span class="token punctuation">.</span><span class="token function">even</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
TypeError<span class="token punctuation">:</span> even is not a <span class="token keyword">function</span>
</code></pre></div><h2 id="es6-模块的转码"><a href="#es6-模块的转码" aria-hidden="true" class="header-anchor">#</a> ES6 模块的转码</h2> <p>浏览器目前还不支持 ES6 模块，为了现在就能使用，可以将其转为 ES5 的写法。除了 Babel 可以用来转码之外，还有以下两个方法，也可以用来转码。</p> <h3 id="es6-module-transpiler"><a href="#es6-module-transpiler" aria-hidden="true" class="header-anchor">#</a> ES6 module transpiler</h3> <p>ES6 module transpiler是 square 公司开源的一个转码器，可以将 ES6 模块转为 CommonJS 模块或 AMD 模块的写法，从而在浏览器中使用。</p> <p>首先，安装这个转码器。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">npm</span> <span class="token function">install</span> -g es6-module-transpiler
<span class="token comment"># 然后，使用compile-modules convert命令，将 ES6 模块文件转码。</span>

$ compile-modules convert file1.js file2.js
<span class="token comment"># -o参数可以指定转码后的文件名。</span>

$ compile-modules convert -o out.js file1.js
</code></pre></div><h3 id="systemjs"><a href="#systemjs" aria-hidden="true" class="header-anchor">#</a> SystemJS</h3> <p>另一种解决方法是使用 SystemJS。它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。</p> <p>使用时，先在网页内载入system.js文件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;system.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 然后，使用System.import方法加载模块文件。</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  System<span class="token punctuation">.</span><span class="token function">import</span><span class="token punctuation">(</span><span class="token string">'./app.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 上面代码中的./app，指的是当前目录下的 app.js 文件。它可以是 ES6 模块文件，System.import会自动将其转码。</span>

<span class="token comment">// 需要注意的是，System.import使用异步加载，返回一个 Promise 对象，可以针对这个对象编程。下面是一个模块文件。</span>

<span class="token comment">// app/es6-file.js:</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">q</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>es6 <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 然后，在网页内加载这个模块文件。</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>

System<span class="token punctuation">.</span><span class="token function">import</span><span class="token punctuation">(</span><span class="token string">'app/es6-file'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">m<span class="token punctuation">.</span>q</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>es6<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 上面代码中，System.import方法返回的是一个 Promise 对象，所以可以用then方法指定回调函数。</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/knowledge/assets/js/app.eebf957d.js" defer></script><script src="/knowledge/assets/js/62.9dc9d9b0.js" defer></script>
  </body>
</html>
